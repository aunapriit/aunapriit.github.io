<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Is it worth attending dog show in Estonia? | using CatBoost on dogs</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.6.3/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--<link rel="icon" type="image/png" href="images/favicon.png">-->
</head>
<style>
.section {
  padding: 8rem 0 7rem;
  text-align: justify;
  margin-bottom: 1.2rem;
  border-bottom: 1px solid #ddd;
}
.section-heading,
.section-description {
  margin-bottom: 1.2rem;
}
</style>
<body>
  <div class="section">
    <div class="container">
      <div class="row">
        <div class="one columns"></div>
        <div class="eleven columns">
          <div id="myPlot">
            <!-- Plotly chart div -->
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="row">
        <div class="eleven columns" id="dogsDiv" style="font-size: 0.8em"></div>
        <div class="one columns">select dog from left</div>
      </div>

      <div class="row">
        <div class="one columns">select judge from right</div>
        <div class="eleven columns" id="judgesDiv" style="font-size: 0.8em"></div>
      </div>
    </div>
    <div class="container">
      <div class="row">
        <div class="eleven columns">
          The big marker (or dot) in plot is a predicted result, tiny one is the real grade given by judge. It is
          generated by some dog show data held in Estonia using CatBoost algorithm. The classification model precision
          on is 0.22 (22%), so it might be better to throw a dart. As there is no data revelance about dog qualities or
          descriptions given by judges, there is no much possibilies to get it better, in this case the information
          assymetry serves the industry. The implementation of CatBoost is shown on my <a
            href="https://github.com/aunapriit/aastakoer/blob/master/aastakoer.py"> github page</a></div>
        <div class="one columns">comment about plot</div>
      </div>
    </div>

  </div>

  <script type="text/javascript">

    var tmp_dogs = new Array();
    var tmp_judges = new Array();
    var list_of_all_judges = new Array();
    var list_of_all_dogs = new Array();
    var data_from_csv = new Array();
    var dog_traces = new Array();


    // change dog name in array and update plot
    function addDog(dogname) {
      tmp_dogs.push(dogname);//add new element to the end of array
      tmp_dogs.shift();//remove first element
      process_data(); // refresh plot
    }


    // change judge name in array and update plot
    function addJudge(judgename) {
      tmp_judges.push(judgename);//add new element to the end of array
      tmp_judges.shift();//remove first element
      process_data();// refresh plot
    }


    // generate random array
    function randomArray(length, max) {
      return Array.apply(null, Array(length)).map(function () {
        return Math.round(Math.random() * max);
      });
    }


    //return only unique values in array
    function onlyUnique(value, index, self) {
      return self.indexOf(value) === index;
    }


    // generate y axis values (dog grades)
    function getgrades(dogname, array_of_judges, array_of_results) {
      let gradelist = new Array(array_of_judges.length).fill(0);// make zero values array for grades
      let predicted_values = new Array(array_of_judges.length).fill(0);// make zero values array for to store predicted / not predicted data
      for (let i = 0; i < array_of_judges.length; i++) {// iteration over judge list, there has to be one grade per judge, ie same length as x
        let currentJudge = array_of_judges[i];
        for (let j = 0; j < array_of_results.length; j++) { // iterate over results
          if (array_of_results[j].judge == currentJudge && array_of_results[j].dog == dogname) {
            gradelist[i] = parseInt(array_of_results[j].grade);// take the grade if current dog and judge are present
            predicted_values[i] = parseInt(array_of_results[j].predicted);// 0 - not predicted, 1 - predicted value
            if (predicted_values[i] == 0) { predicted_values[i] = 7; } else { predicted_values[i] = 15; }// size of the marker is bigger if predicted value
          };
        };
      };//console.log('gradelist: '+gradelist);console.log('predicted_values: '+predicted_values);
      return [gradelist, predicted_values];
    };


    // generate array of results containing selected judges and dogs
    function generata_array_of_results_found(data_from_csv, tmp_judges, tmp_dogs) {
      let results = new Array();
      for (let i = 0; i < data_from_csv.length; i++) {
        let currentDog = data_from_csv[i].koer;
        let currentJudge = data_from_csv[i].kohtunik;
        if (tmp_dogs.includes(currentDog) === true && tmp_judges.includes(currentJudge) === true) {
          results.push({
            dog: data_from_csv[i].koer,
            judge: data_from_csv[i].kohtunik,
            grade: data_from_csv[i].grade,
            predicted: data_from_csv[i].predicted
          });
        };
      };
      return results;
    };


    // generate graph traces for each dog
    function generata_dog_traces(results_found, tmp_judges, tmp_dogs) {
      for (let i = 0; i < tmp_dogs.length; i++) {
        var grades_and_prediction = getgrades(tmp_dogs[i], tmp_judges, results_found);
        var grades = grades_and_prediction[0];
        var predictions = grades_and_prediction[1];
        dog_traces[i] = {
          x: tmp_judges,
          y: grades,
          name: tmp_dogs[i],
          mode: 'lines+markers',
          type: 'scatter',
          marker: { size: predictions }
        };
      };
      return dog_traces;
    };


    //execution of processes after data is loaded
    function process_data() {

      // if tmp_dogs and tmp_judges are not created init them by random and print out judges and dogs on page
      if (tmp_dogs.length < 1 && tmp_judges.length < 1) {
        var ra = randomArray(50, data_from_csv.length); //generate random array to get some results
        for (let i = 0; i < ra.length; i++) { // fill temporary arrays of dogs and judges for vizualisation
          let el_nr = ra[i];
          tmp_judges[i] = data_from_csv[el_nr].kohtunik
          tmp_dogs[i] = data_from_csv[el_nr].koer
        };
        tmp_dogs, tmp_judges = tmp_judges.filter(onlyUnique); // leave only unique names
        tmp_judges.length = 5; // leave only first n elements
        tmp_dogs.length = 3; // leave only first n elements


        for (let i = 0; i < data_from_csv.length; i++) { // fill arrays of dogs and judges to display on page
          list_of_all_judges[i] = data_from_csv[i].kohtunik
          list_of_all_dogs[i] = data_from_csv[i].koer
        };
        list_of_all_judges = list_of_all_judges.filter(onlyUnique);//console.log(judges);
        list_of_all_dogs = list_of_all_dogs.filter(onlyUnique);//console.log(dogs);

        var doglinks = "";
        var judgelinks = "";
        for (var i = 0; i < list_of_all_dogs.length; i++) {
          doglinks = doglinks + " <a onclick='addDog(this.textContent)' href='javascript:void(0);'>" + list_of_all_dogs[i] + "</a>";
          judgelinks = judgelinks + " <a onclick='addJudge(this.textContent)' href='javascript:void(0);'>" + list_of_all_judges[i] + "</a>";
        }

        document.getElementById('judgesDiv').innerHTML = judgelinks;
        document.getElementById('dogsDiv').innerHTML = doglinks;
      }; // end if

      var results_found = generata_array_of_results_found(data_from_csv, tmp_judges, tmp_dogs);//console.log(results_found);
      var dog_traces = generata_dog_traces(results_found, tmp_judges, tmp_dogs);//console.log(dog_traces);

      var layout = { // define plotly layout variables
        xaxis: {
          range: [0, 4]
        },
        yaxis: {
          range: [0, 16]
        },
        title: 'Dog show results by judge'
      };

      Plotly.newPlot('myPlot', dog_traces, layout);//plotly implementation;
    };

    document.addEventListener('DOMContentLoaded', function () {

      Papa.parse("bern.csv", { // Parse CSV file using Papaparse
        download: true,
        header: true,
        complete: function (results) {
          data_from_csv = results.data
          process_data();// process data after loaded
        }
      });


    }, false);

  </script>

</body>

</html>